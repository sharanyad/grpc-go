// Code generated by protoc-gen-go.
// source: sendint.proto
// DO NOT EDIT!

/*
Package sendint is a generated protocol buffer package.

It is generated from these files:
	sendint.proto

It has these top-level messages:
	Wrapper
	WrapperF
	WrapperS
	WrapperComplex
*/
package sendint

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Wrapper struct {
	Number int32 `protobuf:"varint,1,opt,name=number" json:"number,omitempty"`
}

func (m *Wrapper) Reset()                    { *m = Wrapper{} }
func (m *Wrapper) String() string            { return proto.CompactTextString(m) }
func (*Wrapper) ProtoMessage()               {}
func (*Wrapper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type WrapperF struct {
	Number float32 `protobuf:"fixed32,1,opt,name=number" json:"number,omitempty"`
}

func (m *WrapperF) Reset()                    { *m = WrapperF{} }
func (m *WrapperF) String() string            { return proto.CompactTextString(m) }
func (*WrapperF) ProtoMessage()               {}
func (*WrapperF) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type WrapperS struct {
	Number string `protobuf:"bytes,1,opt,name=number" json:"number,omitempty"`
}

func (m *WrapperS) Reset()                    { *m = WrapperS{} }
func (m *WrapperS) String() string            { return proto.CompactTextString(m) }
func (*WrapperS) ProtoMessage()               {}
func (*WrapperS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type WrapperComplex struct {
	Inti    int32   `protobuf:"varint,1,opt,name=inti" json:"inti,omitempty"`
	Floatf  float32 `protobuf:"fixed32,2,opt,name=floatf" json:"floatf,omitempty"`
	Strings string  `protobuf:"bytes,3,opt,name=strings" json:"strings,omitempty"`
}

func (m *WrapperComplex) Reset()                    { *m = WrapperComplex{} }
func (m *WrapperComplex) String() string            { return proto.CompactTextString(m) }
func (*WrapperComplex) ProtoMessage()               {}
func (*WrapperComplex) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func init() {
	proto.RegisterType((*Wrapper)(nil), "Wrapper")
	proto.RegisterType((*WrapperF)(nil), "WrapperF")
	proto.RegisterType((*WrapperS)(nil), "WrapperS")
	proto.RegisterType((*WrapperComplex)(nil), "WrapperComplex")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for SendInt service

type SendIntClient interface {
	EchoInt(ctx context.Context, in *Wrapper, opts ...grpc.CallOption) (*Wrapper, error)
	EchoFloat(ctx context.Context, in *WrapperF, opts ...grpc.CallOption) (*WrapperF, error)
	EchoString(ctx context.Context, in *WrapperS, opts ...grpc.CallOption) (*WrapperS, error)
	EchoComplex(ctx context.Context, in *WrapperComplex, opts ...grpc.CallOption) (*WrapperComplex, error)
}

type sendIntClient struct {
	cc *grpc.ClientConn
}

func NewSendIntClient(cc *grpc.ClientConn) SendIntClient {
	return &sendIntClient{cc}
}

func (c *sendIntClient) EchoInt(ctx context.Context, in *Wrapper, opts ...grpc.CallOption) (*Wrapper, error) {
	out := new(Wrapper)
	err := grpc.Invoke(ctx, "/SendInt/EchoInt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendIntClient) EchoFloat(ctx context.Context, in *WrapperF, opts ...grpc.CallOption) (*WrapperF, error) {
	out := new(WrapperF)
	err := grpc.Invoke(ctx, "/SendInt/EchoFloat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendIntClient) EchoString(ctx context.Context, in *WrapperS, opts ...grpc.CallOption) (*WrapperS, error) {
	out := new(WrapperS)
	err := grpc.Invoke(ctx, "/SendInt/EchoString", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendIntClient) EchoComplex(ctx context.Context, in *WrapperComplex, opts ...grpc.CallOption) (*WrapperComplex, error) {
	out := new(WrapperComplex)
	err := grpc.Invoke(ctx, "/SendInt/EchoComplex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SendInt service

type SendIntServer interface {
	EchoInt(context.Context, *Wrapper) (*Wrapper, error)
	EchoFloat(context.Context, *WrapperF) (*WrapperF, error)
	EchoString(context.Context, *WrapperS) (*WrapperS, error)
	EchoComplex(context.Context, *WrapperComplex) (*WrapperComplex, error)
}

func RegisterSendIntServer(s *grpc.Server, srv SendIntServer) {
	s.RegisterService(&_SendInt_serviceDesc, srv)
}

func _SendInt_EchoInt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Wrapper)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendIntServer).EchoInt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SendInt/EchoInt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendIntServer).EchoInt(ctx, req.(*Wrapper))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendInt_EchoFloat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapperF)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendIntServer).EchoFloat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SendInt/EchoFloat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendIntServer).EchoFloat(ctx, req.(*WrapperF))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendInt_EchoString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapperS)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendIntServer).EchoString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SendInt/EchoString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendIntServer).EchoString(ctx, req.(*WrapperS))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendInt_EchoComplex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapperComplex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendIntServer).EchoComplex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SendInt/EchoComplex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendIntServer).EchoComplex(ctx, req.(*WrapperComplex))
	}
	return interceptor(ctx, in, info, handler)
}

var _SendInt_serviceDesc = grpc.ServiceDesc{
	ServiceName: "SendInt",
	HandlerType: (*SendIntServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EchoInt",
			Handler:    _SendInt_EchoInt_Handler,
		},
		{
			MethodName: "EchoFloat",
			Handler:    _SendInt_EchoFloat_Handler,
		},
		{
			MethodName: "EchoString",
			Handler:    _SendInt_EchoString_Handler,
		},
		{
			MethodName: "EchoComplex",
			Handler:    _SendInt_EchoComplex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("sendint.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 229 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0xd0, 0xc1, 0x4a, 0xc4, 0x30,
	0x10, 0x06, 0xe0, 0x74, 0xd5, 0xcd, 0x76, 0x44, 0x85, 0x39, 0x48, 0xe8, 0x45, 0x8d, 0x1e, 0x3c,
	0x15, 0xd4, 0x47, 0x10, 0x0b, 0x5e, 0x0d, 0xe8, 0x79, 0x6b, 0x53, 0x0d, 0xb4, 0x49, 0x48, 0x23,
	0xf8, 0x48, 0x3e, 0xa6, 0x24, 0x4d, 0x5b, 0x2c, 0xde, 0xfe, 0x69, 0xbf, 0xce, 0xcf, 0x14, 0x4e,
	0x06, 0xa9, 0x1b, 0xa5, 0x7d, 0x69, 0x9d, 0xf1, 0x86, 0x5f, 0x01, 0x7d, 0x73, 0x7b, 0x6b, 0xa5,
	0xc3, 0x73, 0xd8, 0xea, 0xaf, 0xbe, 0x96, 0x8e, 0x65, 0x97, 0xd9, 0xed, 0xd1, 0x4b, 0x9a, 0x38,
	0x87, 0x5d, 0x22, 0xd5, 0xca, 0x6c, 0xfe, 0x31, 0x62, 0x65, 0xf2, 0xd9, 0xbc, 0xc2, 0x69, 0x32,
	0x8f, 0xa6, 0xb7, 0x9d, 0xfc, 0x46, 0x84, 0x43, 0xa5, 0xbd, 0x4a, 0x7d, 0x31, 0x87, 0xaf, 0xdb,
	0xce, 0xec, 0x7d, 0xcb, 0x36, 0x63, 0xc3, 0x38, 0x21, 0x03, 0x3a, 0x78, 0xa7, 0xf4, 0xc7, 0xc0,
	0x0e, 0xe2, 0xda, 0x69, 0xbc, 0xff, 0xc9, 0x80, 0x0a, 0xa9, 0x9b, 0x67, 0xed, 0xf1, 0x02, 0xe8,
	0xd3, 0xfb, 0xa7, 0x09, 0x71, 0x57, 0xa6, 0xb6, 0x62, 0x4e, 0x9c, 0xe0, 0x35, 0xe4, 0x01, 0x54,
	0x61, 0x29, 0xe6, 0xd3, 0x8b, 0xaa, 0x58, 0x22, 0x27, 0x78, 0x03, 0x10, 0x90, 0x88, 0x05, 0x8b,
	0x12, 0x8b, 0x12, 0x9c, 0xe0, 0x1d, 0x1c, 0x07, 0x35, 0x1d, 0x73, 0x56, 0xfe, 0xbd, 0xae, 0x58,
	0x3f, 0xe0, 0xa4, 0xde, 0xc6, 0x9f, 0xfe, 0xf0, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x94, 0x5b, 0x62,
	0xf7, 0x85, 0x01, 0x00, 0x00,
}
